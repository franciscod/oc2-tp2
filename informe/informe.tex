% Clase y configuracion de tipo de documento
\documentclass[10pt,a4paper,spanish]{article}
% Inclusion de paquetes
\usepackage{a4wide}
\usepackage{amsmath, amscd, amssymb, amsthm, latexsym}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[width=15.5cm, left=3cm, top=2.5cm, height= 24.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{longtable}
\usepackage{caratula}
\usepackage{hyperref}
\usepackage{graphicx}
\graphicspath{{img/}}

% Encabezado
\lhead{Organización del Computador II}
\rhead{Grupo: Fuga Villera Nro. 2}
% Pie de pagina
\renewcommand{\footrulewidth}{0.4pt}
\lfoot{Facultad de Ciencias Exactas y Naturales}
\rfoot{Universidad de Buenos Aires}

\begin{document}

% Datos de caratula
\materia{Organización del Computador II}
\titulo{Trabajo Práctico 2: Experimentos}
%\subtitulo{}
\grupo{
	Grupo: Fuga Villera Nro. 2
	\href{https://www.youtube.com/watch?v=wBNjDRXJNyY}{
		\includegraphics[height=0.4cm,keepaspectratio]{YouTube-icon-full_color.png}
	}
}

\integrante{Gabriel Matles}{397/12}{gabriel29m@gmail.com}
\integrante{Manuel Mena}{313/14}{manuelmena1993@gmail.com}
\integrante{Francisco Demartino}{348/14}{demartino.francisco@gmail.com}

\maketitle

\newpage

% Para crear un indice
\tableofcontents

% Forzar salto de pagina
\clearpage

\section{Objetivos generales}

El objetivo de este trabajo práctico es evaluar la eficiencia del modelo de programación SIMD mediante la implementación de diversos algoritmos en lenguaje Ensamblador utilizando instrucciones SSE. \\
\indent Las mediciones se realizan mediante pruebas empíricas del código frente a algoritmos que cumplen la misma especificación, implementados en un lenguaje de alto nivel (C). \\
\indent En este proyecto, los algoritmos a implementar se basaron en el procesamiento de imágenes, en el cual el uso del modelo SIMD es provechoso.

\section{Calidad de las Mediciones}
Antes de medir tiempos y sacar conclusiones de los mismos, es importante tener un esquema básico de como se realizarán las mediciones en el presente trabajo, y bajo que condiciones. \\

\textbf{Características de la computadora en la que los experimentos fueron realizados:} \\
\textit{Procesador:} Intel Core iX XGH X CPUs @ XGHz\\
\textit{Memoria RAM:} X GB \\
\textit{Sistema operativo:} Ubuntu 14.04 64 bits. \\

Las mediciones se realizaron corriendo los filtros X veces cada uno. Se realizó un promedio, y estos promedios son los que se pueden apreciar en los distintos gráficos. Los tiempos están medidos en ¿¿¿¿¿¿¿ciclos de clock??????.

\section{Experimentación}

Los experimentos realizados se dividen dos ramas: en comparar los filtros implementados en C contra los implementados en ASM, y comparar específicamente sobre filtro blur, las distintas implementaciones del mismo. \\

En cuanto a las implementaciones del blur, lo que hicimos fue alternar la forma en la que recorrimos la matriz de convolucion para calcular el valor de cada pixel. En la primer implementación la recorrimos desplazandonos por cada fila hasta llegar al borde derecho y pasar a la suguiente fila. En la otra, en cambio, nos desplazamos por columna (DE ESTO QUIZAS PODRIA HACERSE UN GRAFICO QUE LO ILUSTRE MEJOR, SOBRE TODO LA PARTE DE QUE AGARRAMOS DE A 4 DE UNA MISMA FILA PERO EL MOVIMIENTO ES DE COLUMNA) hasta llegar a la ultima fila y ahi seguimos con las siguientes 4 columnas.

Es necesario destacar dos cosas: gracias a las operaciones SSE podemos computar 4 pixeles simultaneamente, pero estos pixeles son contiguos en memoria, lo que equivale a que estan uno al lado del otro horizontalmente en la imagen. Es por esto que una vez que termino de recorrer la columna, la siguiente será la que se encuentra a 4 posiciones de distancia.
¿HIPOTESIS?:La forma en la que se almacena y se vacía la memoria caché se ve afecatada por la forma en que recorramos la matriz, ya que al hacer un recorrido contiguo en memoria, equivalente a recorrer la imagen horizontalmente, tendrá un mayor hitrate que si la recorremos verticalmente, ya que al no ser contiguas se deberán leer de memoria varios bloques que puedan no encontrarse almacenados. Esto representaría una baja en la performance temporal del algoritmo.

C vs ASM

\begin{enumerate}
	\item Medir los tiempos que tardan los distintos filtros para distintos tamaños de imágenes y para imágenes diferentes. Este experimento tiene como objetivo tener una idea del tiempo de ejecución del algoritmo en general, y comparandolo con otras implementaciones del mismo, tener una idea de cual tiene mejor tiempo de ejecución.
	\item Medir y comparar la memoria utilizada por cada filtro
	\item Registrar la precisión que pueda perderse en cada lenguaje
	\item Repetir los experimentos utilizando la optimización O3 para C
\end{enumerate}

ASM vs ASM

\begin{enumerate}
	\item Medir los tiempos que tardan ambas implementaciones del filtro blur
	\item Registrar el comportamiento de la memoria caché frente a las distintas formas de recorrer las matrices para las implementaciones del filtro blur
\end{enumerate}

\section{Observaciones}
	\includegraphics[keepaspectratio]{gen/diff.png}
	\begin{enumerate}
		\item un item
		\item otro item
	\end{enumerate}

% Otro salto de pagina
% \newpage

\section{Resolución}


% \subsection{Ejercicio X}

\subsection{Auxiliares}

\end{document}
