% Clase y configuracion de tipo de documento
\documentclass[10pt,a4paper,spanish]{article}
% Inclusion de paquetes
\usepackage{a4wide}
\usepackage{amsmath, amscd, amssymb, amsthm, latexsym}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[width=15.5cm, left=3cm, top=2.5cm, height= 24.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{longtable}
\usepackage{caratula}
\usepackage{hyperref}
\usepackage{graphicx}
\graphicspath{{img/}}

\input{codesnippet}

% Encabezado
\lhead{Organización del Computador II}
\rhead{Grupo: Fuga Villera Nro. 2}
% Pie de pagina
\renewcommand{\footrulewidth}{0.4pt}
\lfoot{Facultad de Ciencias Exactas y Naturales}
\rfoot{Universidad de Buenos Aires}

\begin{document}

% Datos de caratula
\materia{Organización del Computador II}
\titulo{Trabajo Práctico 2: Experimentos}
%\subtitulo{}
\grupo{
	Grupo: Fuga Villera Nro. 2
	\href{https://www.youtube.com/watch?v=wBNjDRXJNyY}{
		\includegraphics[height=0.4cm,keepaspectratio]{YouTube-icon-full_color.png}
	}
}

\integrante{Gabriel Matles}{397/12}{gabriel29m@gmail.com}
\integrante{Manuel Mena}{313/14}{manuelmena1993@gmail.com}
\integrante{Francisco Demartino}{348/14}{demartino.francisco@gmail.com}

\maketitle

\newpage

% Para crear un indice
\tableofcontents

% Forzar salto de pagina
\clearpage

\section{Objetivos generales}

El objetivo de este trabajo práctico es evaluar la eficiencia del modelo de programación SIMD mediante la implementación de diversos algoritmos en lenguaje Ensamblador utilizando instrucciones SSE. \\
\indent Las mediciones se realizan mediante pruebas empíricas del código frente a algoritmos que cumplen la misma especificación, implementados en un lenguaje de alto nivel (C). \\
\indent En este proyecto, los algoritmos a implementar se basaron en el procesamiento de imágenes, en el cual el uso del modelo SIMD es provechoso.

\section{Calidad de las Mediciones}
Antes de medir tiempos y sacar conclusiones de los mismos, es importante tener un esquema básico de como se realizarán las mediciones en el presente trabajo, y bajo que condiciones. \\

\textbf{Características de la computadora en la que los experimentos fueron realizados:} \\
\textit{Procesador:} Intel Core iX XGH X CPUs @ XGHz\\
\textit{Memoria RAM:} X GB \\
\textit{Sistema operativo:} Ubuntu 14.04 64 bits. \\

Las mediciones se realizaron corriendo los filtros X veces cada uno. Se realizó un promedio, y estos promedios son los que se pueden apreciar en los distintos gráficos. Los tiempos están medidos en ¿¿¿¿¿¿¿ciclos de clock??????.

\section{Experimentación}

Los experimentos realizados se dividen dos ramas: en comparar los filtros implementados en C contra los implementados en ASM, y comparar específicamente sobre filtro blur, las distintas implementaciones del mismo. \\

En cuanto a las implementaciones del blur, lo que hicimos fue alternar la forma en la que recorrimos la matriz de convolucion para calcular el valor de cada pixel. En la primer implementación la recorrimos desplazandonos por cada fila hasta llegar al borde derecho y pasar a la suguiente fila. En la otra, en cambio, nos desplazamos por columna (DE ESTO QUIZAS PODRIA HACERSE UN GRAFICO QUE LO ILUSTRE MEJOR, SOBRE TODO LA PARTE DE QUE AGARRAMOS DE A 4 DE UNA MISMA FILA PERO EL MOVIMIENTO ES DE COLUMNA) hasta llegar a la ultima fila y ahi seguimos con las siguientes 4 columnas.

Es necesario destacar dos cosas: gracias a las operaciones SSE podemos computar 4 pixeles simultaneamente, pero estos pixeles son contiguos en memoria, lo que equivale a que estan uno al lado del otro horizontalmente en la imagen. Es por esto que una vez que termino de recorrer la columna, la siguiente será la que se encuentra a 4 posiciones de distancia.
¿HIPOTESIS?:La forma en la que se almacena y se vacía la memoria caché se ve afecatada por la forma en que recorramos la matriz, ya que al hacer un recorrido contiguo en memoria, equivalente a recorrer la imagen horizontalmente, tendrá un mayor hitrate que si la recorremos verticalmente, ya que al no ser contiguas se deberán leer de memoria varios bloques que puedan no encontrarse almacenados. Esto representaría una baja en la performance temporal del algoritmo. \\

C vs ASM

\begin{enumerate}
	\item Medir los tiempos que tardan los distintos filtros para distintos tamaños de imágenes y para imágenes diferentes. Este experimento tiene como objetivo tener una idea del tiempo de ejecución del algoritmo en general, y comparandolo con otras implementaciones del mismo, tener una idea de cual tiene mejor tiempo de ejecución.
	\item Medir y comparar la memoria utilizada por cada filtro
	\item Registrar la precisión que pueda perderse en cada lenguaje
	\item Repetir los experimentos utilizando la optimización O3 para C
\end{enumerate}

ASM vs ASM

\begin{enumerate}
	\item Medir los tiempos que tardan ambas implementaciones del filtro blur
	\item Registrar el comportamiento de la memoria caché frente a las distintas formas de recorrer las matrices para las implementaciones del filtro blur
\end{enumerate}


\section{Blur}

\subsection{Introducción}

\textit{Blur} es un filtro que suaviza una imagen. Consta de asignarle a cada componente de la imágen de salida el promedio de la vecindad del mismo en la imágen original. En este trabajo práctico tomaremos el promedio ponderado, para lograr un desenfoque más natural. Se lo llama Blur Gaussiano ya que la matriz que se utiliza para calcular este promedio es calculada a partir de una función Gaussiana. \\

Los bordes de la imágen no se veran afectados por el filtro ya que en esas posiciones de la imagen no se puede tomar la cantidad de vecinos necesaria. \\

(PODRIA HABLAR DE LOS PARAMETROS QUE TOMA EL BLUR)

\subsection{Implementación en C}

En la implementación en C, el cálculo de cada pixel consiste en recorrer los pixeles vecinos utilizando dos índices (x e y), acumular el valor del producto entre cada una de las componentes del pixel y el valor correspondiente de la matriz de convolución, y una vez terminado el recorrido, escribir en la imágen de salida el resultado acumulado para cada una de las componentes. \\

Este es el pseudocódigo de cada iteración del ciclo:

\begin{codesnippet}
\begin{verbatim}

blue = 0
green = 0
red = 0

for x from -radius to radius inclusive do:
  for y from -radius to radius inclusive do:

      blue  += (src_matrix[row + y][(col + x) * 4 + OFFSET_BLUE]) *
                conv_matrix[radius - y][radius - x];

      green += (src_matrix[row + y][(col + x) * 4 + OFFSET_GREEN]) *
                conv_matrix[radius - y][radius - x];

      red   += (src_matrix[row + y][(col + x) * 4 + OFFSET_RED]) *
                conv_matrix[radius - y][radius - x];

dst_matrix[row][col * 4 + OFFSET_BLUE]  = blue;
dst_matrix[row][col * 4 + OFFSET_GREEN] = green;
dst_matrix[row][col * 4 + OFFSET_RED]   = red;
dst_matrix[row][col * 4 + OFFSET_ALPHA] = 255;

\end{verbatim}
\end{codesnippet}

\subsection{Implementación 1 en ASM}

La primera implementación en ASM consiste en procesar el pixel recorriendo la matriz de convolucion fila por fila, cada una de izquierda a derecha.
Calcula un pixel de la imágen de salida a la vez. La ventaja que sacamos de las instrucciones SSE es que para procesar cada fila podemos computar 4 pixeles de la imágen de entrada simultáneamente. \\

Cada pixel tiene 4 componentes, cada una ocupa un byte, por lo que cada pixel ocupa 4 bytes. Dentro de los registros xmm podemos almacenar hasta 16 bytes, por lo que es posible guardar dentro el valor de 4 pixeles. De esta forma podemos obtener el valor de 4 pixeles que serán procesados acorde al uso del modelo SIMD. \\

Para calcular el valor final de cada pixel, nuestra implementación usa 2 indices que representaran la posición actual (x,y) y que utilizamos para recorrer los vecinos. Dentro de el ciclo del recorrido, lee de memoria 4 pixeles y los almacena en un registro xmm para luego copiarlo en otros 3 que usaremos para separarlos por componente (no son 4 ya que la componente alpha tiene como valor 255 siempre).

% \begin{codesnippet}
% \begin{verbatim}
	
	

% \end{verbatim}
% \end{codesnippet}

% \section{Observaciones}
% 	\includegraphics[keepaspectratio]{gen/diff.png}
% 	\begin{enumerate}
% 		\item un item
% 		\item otro item
% 	\end{enumerate}

% \section{Resolución}

% \vspace*{0.3cm}
% $xmm0=  0|b_{sup1}$ $g_{sup1}$ $r_{sup1}$ $a_{sup1}$ 

% % \subsection{Ejercicio X}

% \subsection{Auxiliares}

\end{document}
